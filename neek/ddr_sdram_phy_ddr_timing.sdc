## This file constrains the auto-calibrating memory interface
## You may need to edit the parameters at the top of this file
## to match your memory device.
## Generated by:8.0
set t(period) 7.518
set t(board_skew) 0.020
set t(DS) 0.400
set t(DH) 0.400
set t(AC) 0.700
set t(IS) 0.600
set t(IH) 0.600
set t(DSS) 0.2
set t(DSH) 0.2
set t(DQSS) 0.28
set t(DQSQ) 0.400
set t(QHS) 0.500
set t(DQSCK) 0.550
set t(capture_shift) 2.2
set t(resync_shift) 2.480
set t(HP) 3.383
if {$::TimeQuestInfo(family) == "Arria GX"} {
set t(mimic_shift) 2.200
} elseif {$::TimeQuestInfo(family) == "HardCopy II"} {
set t(mimic_shift) 2.000
} elseif {$::TimeQuestInfo(family) == "Cyclone III"} {
set t(mimic_shift) 2.500
} else {
set t(mimic_shift) 1.600
}
set t(calibration_error) 1.144
set t(additional_addresscmd_tpd) 0.000
set corename "ddr_sdram_phy"
set t(inclk_period) 20.000
set t(DCD_total) 0.250
set t(PLL_PSERR) 0.060
##
##Legal Notice: (C)2007 Altera Corporation. All rights reserved. Your
##use of Altera Corporation's design tools, logic functions and other
##software and tools, and its AMPP partner logic functions, and any
##output files any of the foregoing (including device programming or
##simulation files), and any associated documentation or information are
##expressly subject to the terms and conditions of the Altera Program
##License Subscription Agreement or other applicable license agreement,
##including, without limitation, that your use is for the sole purpose
##of programming logic devices manufactured by Altera and sold by Altera
##or its authorized distributors. Please refer to the applicable
##agreement for further details.
proc ddr_pin {n pin pins_array_name} {
  upvar 1 $pins_array_name pins
  global pins
  #puts "ddr_pin $n $pin $pins_array_name"
  if {![info exists pins($n)] } {
    post_message -type critical_warning "ddr_pin $n $pin $pins_array_name didn't recognise '$n' as a pin type"
  } else {
    lappend pins($n) $pin
  }
}
set pin_file_name "ddr_sdram_phy_ddr_pins.tcl"
set dirname [file dirname [info script]] 
set fn [file join $dirname $pin_file_name]
source $fn

proc add_requirements_for_instance {corename instance_name t_name ddr_sdram_phy_use_high_performance_timing} {
upvar 1 $t_name t
set instname "${instance_name}|${corename}"
global ck_output_clocks
array unset ck_output_clocks
global pins
array unset pins
set pins(ck_p) [list]
set pins(ck_n) [list]
set pins(addrcmd) [list]
set pins(addrcmd_2t) [list]
set pins(dqsgroup) [list]
set pins(dgroup) [list]

global pins_cache
if { [array exists pins_cache] &&  [info exists pins_cache($corename-$instance_name)] } {
  # post_message -type critical_warning "cache hit"
  array set pins $pins_cache($corename-$instance_name)
} else {
  # post_message -type critical_warning "cache miss"
  get_ddr_pins $instname pins
  set pins_cache($corename-$instance_name) [array get pins]
}

set msg_list [list]
set ck_pll_clock_id [get_output_clock_id $pins(ck_p) "CK output" msg_list]
if {$ck_pll_clock_id == -1} {
  foreach {msg_type msg} $msg_list {
    post_message -type $msg_type "ddr_sdram_phy_ddr_timing.sdc: $msg"
  }
  post_message -type warning "ddr_sdram_phy_ddr_timing.sdc: Failed to find PLL clock for pins [join $pins(ck_p)]"
} else {
  set ck_pll_clock [get_node_info -name $ck_pll_clock_id]
  set pll_ref_clk_id [get_input_clk_id $ck_pll_clock_id]
  if {$pll_ref_clk_id != -1} {
    set pll_ref_clk [get_node_info -name $pll_ref_clk_id]
    if {[get_collection_size [get_clocks -nowarn $pll_ref_clk]] == 0} {
      create_clock -period $t(inclk_period) $pll_ref_clk
    }

    if {[get_collection_size [get_clocks -nowarn $ck_pll_clock]] > 0} {
      # PLL clocks already derived
    } else {
      derive_pll_clocks
    }
  } else {
    post_message -type info "ddr_sdram_phy_ddr_timing.sdc: Could not find PLL clocks for $ck_pll_clock. Creating PLL base clocks"
    # Attempt to recover
    derive_pll_clocks -create_base_clocks
  }
  # Note that derive_clock_uncertainty -add will add the PLL jitter, SPE, and clock network jitter uncertainties during update_timing_netlist, so it can be called multiple times but will only apply uncertainties once
  derive_clock_uncertainty -add
}

set resync_clock_pattern ${instname}_alt_mem_phy_ciii_inst|clk|*|altpll_component|auto_generated|pll1|clk\[3\]
set resync_clock_id ""
sett_collection resync_clock_id [get_pins -compatibility_mode $resync_clock_pattern]
set resync_clock [get_node_info -name $resync_clock_id]
set resync_pll_ref_clk_id [get_input_clk_id $resync_clock_id]
if {$resync_pll_ref_clk_id != -1} {
  set resync_pll_ref_clk [get_node_info -name $resync_pll_ref_clk_id]
  if {[get_collection_size [get_clocks -nowarn $resync_pll_ref_clk]] == 0} {
    create_clock -period $t(inclk_period) $resync_pll_ref_clk
  }
} else {
  post_message -type warning "ddr_sdram_phy_ddr_timing.sdc: Failed to find PLL input clock pin driving $resync_clock"
}
set mimic_clock_pattern ${instname}_alt_mem_phy_ciii_inst|clk|*|altpll_component|auto_generated|pll1|clk\[4\]
set mimic_clock_pins [get_pins -nowarn -compatibility_mode $mimic_clock_pattern]
if {[get_collection_size $mimic_clock_pins] == 1} {
  set mimic_clock_id ""
  sett_collection mimic_clock_id $mimic_clock_pins
  set mimic_clock [get_node_info -name $mimic_clock_id]
} else {
  set mimic_clock ""
}
set system_clock_pattern ${instname}_alt_mem_phy_ciii_inst|clk|*|altpll_component|auto_generated|pll1|clk\[0\]
set system_clock_pins [get_pins -nowarn -compatibility_mode $system_clock_pattern]
if {[get_collection_size $system_clock_pins] == 1} {
  set system_clock_id ""
  sett_collection system_clock_id $system_clock_pins
  set system_clock [get_node_info -name $system_clock_id]
  if {[info exists pll_ref_clk]} {
    set_false_path -from $pll_ref_clk -to $system_clock
    set_false_path -to $pll_ref_clk -from $system_clock
  }
} else {
  set system_clock ""
}
# Not QDR datapath.
set dirname [file dirname [info script]] 
set fn [file join $dirname ${corename}_cu.tcl]
if { $::TimeQuestInfo(family) == "HardCopy II" &&  [file exists $fn]} {
  source [file join $dirname $fn]
  foreach s [list fpga_tREAD_CAPTURE_SETUP_ERROR fpga_tREAD_CAPTURE_HOLD_ERROR fpga_RESYNC_SETUP_ERROR fpga_RESYNC_HOLD_ERROR fpga_PA_DQS_SETUP_ERROR fpga_PA_DQS_HOLD_ERROR WR_DQS_DQ_SETUP_ERROR WR_DQS_DQ_HOLD_ERROR fpga_tCK_ADDR_CTRL_SETUP_ERROR fpga_tCK_ADDR_CTRL_HOLD_ERROR fpga_tDQSS_SETUP_ERROR fpga_tDQSS_HOLD_ERROR fpga_tDSSH_SETUP_ERROR fpga_tDSSH_HOLD_ERROR] {
    if { ! [info exists $s] } {
      post_message -type critical_warning "ALTMEMPHY: Missing setting in $fn:$s"
    }
  }
} else {
  if { $::TimeQuestInfo(family) == "HardCopy II" } {
    if { $::TimeQuestInfo(nameofexecutable) != "quartus_fit"} {
      post_message -type warning "HardCopy II clock uncertainty file $fn could not be found"
    }
  }
set fpga_tREAD_CAPTURE_SETUP_ERROR 0
set fpga_tREAD_CAPTURE_HOLD_ERROR 0
set fpga_RESYNC_SETUP_ERROR 0
set fpga_RESYNC_HOLD_ERROR 0
set fpga_PA_DQS_SETUP_ERROR 0
set fpga_PA_DQS_HOLD_ERROR 0
set WR_DQS_DQ_SETUP_ERROR 0
set WR_DQS_DQ_HOLD_ERROR 0
set fpga_tCK_ADDR_CTRL_SETUP_ERROR 0
set fpga_tCK_ADDR_CTRL_HOLD_ERROR 0
set fpga_tDQSS_SETUP_ERROR 0
set fpga_tDQSS_HOLD_ERROR 0
set fpga_tDSSH_SETUP_ERROR 0
set fpga_tDSSH_HOLD_ERROR 0
}
# post_message -type info "Creating CK output clocks"
set ck_clock_types_list [list tDSS tDQSS ac_rise ac_fall]
set source $ck_pll_clock
foreach ckpin [concat $pins(ck_p) $pins(ck_n)] {
  if { [lsearch -exact $pins(ck_p) $ckpin] != -1 } { 
    set invert 0
    set ckpn p
  } elseif { [lsearch -exact $pins(ck_n) $ckpin] != -1 } {
    set invert 1
    set ckpn n
  } else {
    error "Can't find pin $ckpin in $pins(ck_p) or $pins(ck_n)"
  }
  # We don't care about the tco of the memory clocks
  set_false_path -from * -to [get_ports $ckpin]
  set clocknamestub "${instname}_ck_${ckpn}_${ckpin}"
  foreach ck_clock_type $ck_clock_types_list {
    set clockname "${clocknamestub}_${ck_clock_type}"
    if { $invert } { 
      create_generated_clock -add -multiply_by 1 -source $source -master_clock $source -invert -name $clockname $ckpin
    } else { 
      create_generated_clock -add -multiply_by 1 -source $source -master_clock $source -name $clockname $ckpin
    }
    add_output_clock $ck_clock_type $ckpn $clockname
  }
}
# calibrated capture clock
set capture_clockname "${instname}_ddr_capture"
set capture_pattern ${instname}_alt_mem_phy_ciii_inst|dpio|dqs_group\[*\].dq\[*\].dqi|auto_generated|input_cell_*\[0\]|clk
create_clock -period $t(period) -name $capture_clockname [get_pins -compatibility_mode $capture_pattern] -add
set count 0
foreach_in_collection reg [get_pins -compatibility_mode $capture_pattern] {
  set clockname "${instname}_dq_[incr count]"
  create_generated_clock -name $clockname -source [get_pins -compatibility_mode $resync_clock] [get_pin_info -name $reg] -add
  set_false_path -from [get_ports *] -to [get_clocks $clockname]
}
set_false_path -from [get_clocks $capture_clockname] -to [get_clocks $resync_clock]
# measure clock
set measure_clockname ${instname}_ddr_mimic
set measure_pattern ${instname}_alt_mem_phy_ciii_inst|clk|DDR_CLK_OUT\[0\].ddr_clk_out_p|auto_generated|input_cell_h\[0\]|clk
sett_collection c [get_pins -compatibility_mode $measure_pattern]
set source [get_node_info -name $c]
create_clock -period $t(period) -name $measure_clockname $source -add
set_false_path -from [get_clocks $mimic_clock] -to $measure_clockname
set_false_path -to   [get_clocks $mimic_clock] -from $measure_clockname
foreach ck_clock_type_pn [array names ck_output_clocks] {
  set_false_path -from [get_clocks $ck_output_clocks($ck_clock_type_pn)] -to [get_clocks $measure_clockname]
}
set scan_clock_patterns [list ${instname}_alt_mem_phy_ciii_inst|clk|scan_clk|q 2]
foreach {pattern divide_by} $scan_clock_patterns {
  foreach_in_collection c [get_pins -compatibility_mode $pattern] {
set source [get_node_info -name $c]
set sys_pll_clock [get_pll_clock [list $c] "System" "" 16]
if {$sys_pll_clock != ""} {
    post_sdc_message info "Creating scan clock ${source}_clock driven by $sys_pll_clock divided by $divide_by"
    create_generated_clock -multiply_by 1 -divide_by $divide_by -source $sys_pll_clock -master_clock $sys_pll_clock $source -name ${source}_clock
  set_max_delay -to [get_clocks $sys_pll_clock] -from [get_clocks ${source}_clock] 9.0
  set_max_delay -from [get_clocks $sys_pll_clock] -to [get_clocks ${source}_clock] 9.0
  set_min_delay -to [get_clocks $sys_pll_clock] -from [get_clocks ${source}_clock] -9.0
  set_min_delay -from [get_clocks $sys_pll_clock] -to [get_clocks ${source}_clock] -9.0
} else {
  post_message -type warning "Cannot find source clock of $source"
}
  }
}
set msg_list [list]
set dqs_pll_clock_id [get_output_clock_id [get_all_dqs_pins $pins(dqsgroup)] "DQS output" msg_list]
set dq_pll_clock_id [get_output_clock_id [get_all_dq_pins $pins(dqsgroup)] "DQ output" msg_list]
if {$dqs_pll_clock_id == -1 || $dq_pll_clock_id == -1} {
  foreach {msg_type msg} $msg_list {
    post_message -type $msg_type "ddr_sdram_phy_ddr_timing.sdc: $msg"
  }
  post_message -type warning "ddr_sdram_phy_ddr_timing.sdc: Failed to find PLL clock for pins [join [get_all_dqs_pins $pins(dqsgroup)]]"
} else {
  set dqsclksource [get_node_info -name $dqs_pll_clock_id]
  set dqclksource [get_node_info -name $dq_pll_clock_id]
}
foreach dqsgroup $pins(dqsgroup) {
  set dqspin [lindex $dqsgroup 0]
  if {!$ddr_sdram_phy_use_high_performance_timing} {
  # DQS output clock
  set dqs_out_clockname "${instname}_ddr_dqsout_${dqspin}"
  create_generated_clock -multiply_by 1 -source $dqsclksource -master_clock $dqsclksource $dqspin -name $dqs_out_clockname -add
  }
  # endif !ddr_sdram_phy_use_high_performance_timing
  if {!$ddr_sdram_phy_use_high_performance_timing} {
  set_output_delay -add_delay -clock $dqs_out_clockname -max [round_3dp [expr {$t(board_skew) + $t(DS) + $WR_DQS_DQ_SETUP_ERROR}]] [concat [lindex $dqsgroup 1] [lindex $dqsgroup 2]]
  set_output_delay -add_delay -clock $dqs_out_clockname -min [round_3dp [expr {-$t(DH) - $t(board_skew) - $t(DCD_total) - $WR_DQS_DQ_HOLD_ERROR}]] [concat [lindex $dqsgroup 1] [lindex $dqsgroup 2]]
  set_output_delay -add_delay -clock_fall -clock $dqs_out_clockname -max [round_3dp [expr {$t(board_skew) + $t(DS) + $WR_DQS_DQ_SETUP_ERROR}]] [concat [lindex $dqsgroup 1] [lindex $dqsgroup 2]]
  set_output_delay -add_delay -clock_fall -clock $dqs_out_clockname -min [round_3dp [expr {-$t(DH) - $t(board_skew) - $t(DCD_total) - $WR_DQS_DQ_HOLD_ERROR}]] [concat [lindex $dqsgroup 1] [lindex $dqsgroup 2]]
  }
  # endif !ddr_sdram_phy_use_high_performance_timing
# DQS vs CK
    set off_tDQSS 0
    set off_tDSS 0
foreach ckclock [get_output_clocks tDQSS p] {
  set_output_delay -add_delay -clock $ckclock -max [round_3dp [expr {($off_tDQSS+1-$t(DQSS)) * $t(period) + $t(board_skew) + $fpga_tDQSS_SETUP_ERROR}]] $dqspin
  set_output_delay -add_delay -clock $ckclock -min [round_3dp [expr {($off_tDQSS+$t(DQSS)) * $t(period) - $t(board_skew) - $fpga_tDQSS_HOLD_ERROR}]] $dqspin
}
foreach ckclock [get_output_clocks tDQSS n] {
  set_output_delay -add_delay -clock_fall -clock $ckclock -max [round_3dp [expr {($off_tDQSS+1-$t(DQSS)) * $t(period) + $t(board_skew) + $fpga_tDQSS_SETUP_ERROR}]] $dqspin
  set_output_delay -add_delay -clock_fall -clock $ckclock -min [round_3dp [expr {($off_tDQSS+$t(DQSS)) * $t(period) - $t(board_skew) - $fpga_tDQSS_HOLD_ERROR}]] $dqspin
}
foreach ckclock [concat [get_output_clocks tDQSS p] [get_output_clocks tDQSS n]] {
  set_false_path -to [get_clocks $ckclock] -fall_from [get_clocks $dqsclksource]
}
foreach ckclock [get_output_clocks tDSS p] {
  set_output_delay -add_delay -clock $ckclock -max [round_3dp [expr {($off_tDSS+$t(DSS)) * $t(period) + $t(board_skew) + $fpga_tDSSH_SETUP_ERROR}]] $dqspin
  set_output_delay -add_delay -clock $ckclock -min [round_3dp [expr {($off_tDSS-$t(DSH)) * $t(period) - $t(board_skew) - $fpga_tDSSH_HOLD_ERROR}]] $dqspin
}
foreach cknclock [get_output_clocks tDSS n] {
  set_output_delay -add_delay -clock_fall -clock $cknclock -max [round_3dp [expr {($off_tDSS+$t(DSS)) * $t(period) + $t(board_skew) + $fpga_tDSSH_SETUP_ERROR}]] $dqspin
  set_output_delay -add_delay -clock_fall -clock $cknclock -min [round_3dp [expr {($off_tDSS-$t(DSH)) * $t(period) - $t(board_skew) - $fpga_tDSSH_HOLD_ERROR}]] $dqspin
}
foreach ckclock [concat [get_output_clocks tDSS p] [get_output_clocks tDSS n]] {
  # DSS and DSH are only for falling edge of DQS
  set_false_path -to [get_clocks $ckclock] -rise_from [get_clocks $dqsclksource]
}
# Only analyze the DDIO mux select path to the DQS output
set_false_path -from [all_registers] -to [get_ports $dqspin]
}
set x [expr {$t(HP) - 2*$t(AC) - $t(calibration_error)}]
set_max_delay -from [get_all_dq_pins $pins(dqsgroup)] -to [all_registers] [round_3dp [expr {$t(capture_shift) + 0.5*$x}]]
set_min_delay -from [get_all_dq_pins $pins(dqsgroup)] -to [all_registers] [round_3dp [expr {$t(capture_shift) - 0.5*$x}]]
set capture_clock $resync_clock
set_false_path -from [get_all_dq_pins $pins(dqsgroup)] -to [get_clocks $capture_clock]
set_false_path -to [get_pins -compatibility_mode ${instname}_alt_mem_phy_ciii_inst|dpio|dqs_group\[*\].dq\[*\].dqi|auto_generated|input_*_*\[0\]|clrn]


if {$ddr_sdram_phy_use_high_performance_timing} {
  # Cut paths to read capture registers
  set dq_list [get_all_dq_pins $pins(dqsgroup)]
  if {[llength $dq_list] > 0} {
    set_false_path -from [concat $dq_list] -to [all_registers]
  }
  # Cut paths from write registers and PLL clocks-as-data
  set d_dm_list [concat $dq_list [get_all_dm_pins $pins(dqsgroup)]]
  if {[llength $d_dm_list] > 0} {
  	set_false_path -from * -to $d_dm_list
  }
}
# endif ddr_sdram_phy_use_high_performance_timing

# Mimic Path
foreach ck $pins(ck_p) {
  create_clock -period $t(period) $ck -name ${instname}_${ck}_mimic_launch_clock -add
}
set_max_delay -from [get_clocks ${instname}_${ck}_mimic_launch_clock] -to  [get_clocks *ddr_mimic]  $t(mimic_shift)
set clear_list [list \
  ${instname}_alt_mem_phy_ciii_inst|clk|*pll|altpll_component|auto_generated|pll_lock_sync|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|global_pre_clear|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|reset_master_ams|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|mem_pipe|ams_pipe\[*\]|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|mem_clk_pipe|ams_pipe\[*\]|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|write_clk_pipe|ams_pipe\[*\]|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|measure_clk_pipe|ams_pipe\[*\]|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|resync_clk_pipe|ams_pipe\[*\]|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|clk_div_reset_ams_n_r|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|clk_div_reset_ams_n|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|pll_reconfig_reset_ams_n_r|clrn \
  ${instname}_alt_mem_phy_ciii_inst|clk|pll_reconfig_reset_ams_n|clrn \
]
foreach clear $clear_list {
  set clear_pins [get_pins -nowarn -compatibility_mode $clear]
  if {[get_collection_size $clear_pins] > 0} {
    set_false_path -thru $clear_pins -to *
  }
}
# Address Command
# post_message -type info "Address/Command"
set msg_list [list]
set ac_pll_clock_id [get_output_clock_id $pins(addrcmd) "Address/Command output" msg_list]
if {$ac_pll_clock_id == -1} {
  foreach {msg_type msg} $msg_list {
    post_message -type $msg_type "ddr_sdram_phy_ddr_timing.sdc: $msg"
  }
  post_message -type warning "ddr_sdram_phy_ddr_timing.sdc: Failed to find PLL clock for pins [join $pins(addrcmd)]"
} else {
  set ac_pll_clock [get_node_info -name $ac_pll_clock_id]
  set ded_off_rise 0
  set ded_off_fall 0
set off $ded_off_fall
# Only analyze the DDIO mux select
set_false_path -from [all_registers] -to [concat $pins(addrcmd) $pins(addrcmd_2t)]
foreach ckclock [get_output_clocks ac_fall p] {
  set_output_delay -add_delay -clock $ckclock -max [round_3dp [expr {$off*$t(period) + $t(IS) + $t(board_skew) + $t(DCD_total) + $fpga_tCK_ADDR_CTRL_SETUP_ERROR + $t(additional_addresscmd_tpd)}]] [concat $pins(addrcmd) $pins(addrcmd_2t)]
  set_output_delay -add_delay -clock $ckclock -min [round_3dp [expr {$off*$t(period) - $t(IH) - $t(board_skew) - $t(DCD_total) - $fpga_tCK_ADDR_CTRL_HOLD_ERROR  + $t(additional_addresscmd_tpd)}]] [concat $pins(addrcmd) $pins(addrcmd_2t)]
}
foreach ckclock [get_output_clocks ac_fall n] {
  set_output_delay -add_delay -clock_fall -clock $ckclock -max [round_3dp [expr {$off*$t(period) + $t(IS) + $t(board_skew) + $t(DCD_total) + $fpga_tCK_ADDR_CTRL_SETUP_ERROR + $t(additional_addresscmd_tpd)}]] [concat $pins(addrcmd) $pins(addrcmd_2t)]
  set_output_delay -add_delay -clock_fall -clock $ckclock -min [round_3dp [expr {$off*$t(period) - $t(IH) - $t(board_skew) - $t(DCD_total) - $fpga_tCK_ADDR_CTRL_HOLD_ERROR  + $t(additional_addresscmd_tpd)}]] [concat $pins(addrcmd) $pins(addrcmd_2t)]
}
if {$ac_pll_clock_id != -1} {
  foreach ckclock [concat [get_output_clocks ac_fall p] [get_output_clocks ac_fall n]] {
    set_false_path -rise_from [get_clocks $ac_pll_clock] -to $ckclock
  }
}
}
if { [llength $pins(addrcmd_2t)] > 0 } {
  # post_message -type info "Address/Command (half rate)"
  set_multicycle_path -setup -to $pins(addrcmd_2t) 2
  set_multicycle_path -hold -to $pins(addrcmd_2t) 1
}

}


set instance_list [get_core_instance_list $corename]
foreach inst $instance_list {
	post_sdc_message info "Adding SDC requirements for $corename instance $inst"
	add_requirements_for_instance $corename $inst t $ddr_sdram_phy_use_high_performance_timing
	add_ddr_report_command "source [list [file join [file dirname [info script]] ${corename}_report_timing.tcl]]"
}
